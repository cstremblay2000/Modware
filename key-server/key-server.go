/**
 * file:		client.go
 * author:		Mohammad Eshan <me3031@rit.edu>
 *				Chris Tremblay <cst1465@rit.edu>
 * language: 	Go
 * date:		4/19/2023, National Garlic Day!
 * description
 * 	The KeyServer
 */

package main

import (
	"crypto/rsa"
	"fmt"
	"log"
	"net"
	"os"
	"path/filepath"
	"strings"
)

const (
	keyDir       = "keys"
	keyExtension = ".pem"
	HOST         = "localhost"
	PORT         = "5023"
	TYPE         = "tcp"
)

/**
 * description:
 *	The struct definintion to map an IP to public key
 */
type KeyStorage struct {
	keys map[string]*rsa.PublicKey
}

/**
 * description:
 *	create a new KeyStorage struct
 * returns:
 *	The struct 
 */
func NewKeyStorage() *KeyStorage {
	return &KeyStorage{keys: make(map[string]*rsa.PublicKey)}
}

/**
 * description:
 *	Add a key to the KeyStorage in-memory map
 * parameters:
 *	ip -> the IP we want to be the key
 *	key -> the public key of the IP
 */
func (ks *KeyStorage) AddKey(ip string, key *rsa.PublicKey) {
	ks.keys[ip] = key
}

/**
 * description:
 *	Get the key associated with an IP in memory
 * parameters:
 * 	ip -> the IP we want to get the key of
 * returns:
 *	the key and true, if successful
 * 	something and false, othersise
 */
func (ks *KeyStorage) GetKey(ip string) (*rsa.PublicKey, bool) {
	key, ok := ks.keys[ip]
	return key, ok
}

/**
 * description:
 *	print a log message with a key-server tag
 */
func printLog(msg string) {
	fmt.Println("[key-server]", msg)
}

/**
 * description:
 * 
 * parameters:
 *
 * returns:
 *	nil -> upon success
 *	error -> otherwise
 */
func givePublicKey(conn net.Conn, keyStorage *KeyStorage) error {
	ip := conn.RemoteAddr().(*net.TCPAddr).IP.String()

	pubKey, ok := keyStorage.GetKey(ip)
	if !ok {
		log.Printf("No public key found for IP: %s\n", ip)
		return fmt.Errorf("no public key found for IP: %s", ip)
	}

	challenge, err := MakeChallenge()
	if err != nil {
		log.Printf("Error making challenge: %v", err)
		return err
	}

	encryptedChallenge, err := RsaEncrypt(*pubKey, []byte(challenge))
	if err != nil {
		log.Printf("Error encrypting challenge: %v", err)
		return err
	}

	encPacket := EncryptedPacket{
		Challenge: encryptedChallenge,
		Pmc:       *pubKey,
	}

	encPacketBytes, err := encryptedPacketToBytes(encPacket)
	if err != nil {
		log.Printf("Error encoding encrypted packet: %v", err)
		return err
	}

	_, err = conn.Write(encPacketBytes)
	if err != nil {
		log.Printf("Error sending encrypted packet: %v", err)
		return err
	}

	log.Printf("Sent encrypted challenge and public key for IP: %s\n", ip)
	return nil
}

/**
 * description:
 *	the key server side implementation for the verify host protocol flow
 *	
 *	1) a unique challenge is generated by KeyServer
 *	2) the KeyServer loads the stored secret key of the ModwareServer
 *	   that the ModwareClient wants to talk to
 *	3) the KeyServer uses the ModwareServer secret key to sign the challenge
 *	4) the KeyServer then signs the ModwareServer signature of the challenge
 *	5) the data is packaged into a struct, encoded to bytes, encrypted then sent
 * parameters:
 *	conn -> the connection to the ModwareClient
 *	pubKeyModwareServer -> the public key of the ModwareServer
 *	ip -> the ip of the client?
 *	privKeyServer -> the private key of the ModwareServer
 *	pubKeyCleint -> the public key of the client 
 * returns:
 *	nil -> upon sucess
 *	error -> otherwise
 */
func sendEncryptedPublicKey(
		conn net.Conn, 
		pubKeyModwareServer *rsa.PublicKey, 
		ip string, 
		privKeyServer *rsa.PrivateKey, 
		pubKeyClient *rsa.PublicKey,
	) error {
	// create unique challenge
	challenge, err := MakeChallenge()
	if err != nil {
		log.Printf("Error making challenge: %v", err)
		return err
	}

	// sign challenge with the stored secret key of the
	// ModwareServer the ModwareClient is trying to talk to
	sigChall, err := RsaSign(privKeyServer, []byte(challenge))
	if err != nil {
		log.Printf("Error signing challenge: %v", err)
		return err
	}

	// have the KeyServer sign the ModwareServer challenge signature
	sigKS, err := RsaSign(privKeyServer, sigChall)
	if err != nil {
		log.Printf("Error signing sigChall: %v", err)
		return err
	}

	// create struct of data to send
	dataToSend := KeyServerToModwareClient {
		PublicKey: *pubKeyModwareServer,
		Chall:     []byte(challenge),
		SigChall:  sigChall,
		SigKS:     sigKS,
	}

	// encode struct to bytes
	encodedDataToSend, err := KeyServerToModwareClientToBytes( dataToSend )
	if err != nil {
		log.Printf("Error encoding struct to bytes: %v", err)
		return err
	}

	// encrypt the bytes and send
	encryptedDataToSend, err := RsaEncrypt( *pubKeyClient, encodedDataToSend )
	if err != nil {
		log.Printf( "Error encrypting packet: %v", err )
		return err 
	}
	_, err = conn.Write(encryptedDataToSend)
	if err != nil {
		log.Printf("Error sending encrypted data: %v", err)
		return err
	}

	// done
	log.Printf("Sent encrypted public key, challenge, and signatures for IP: %s\n", ip)
	return nil
}

/**
 * description
 *	handle an incoming request
 *	should only ever be a ModwareClient
 * parameters:
 *	conn -> the connection to the ModwareClient (allegedly)
*	keyStorage -> the in-memory ip to public key storage
 */
func handleRequest(conn net.Conn, keyStorage *KeyStorage) {
	defer conn.Close()

	buf := make([]byte, 1024)

	reqLen, err := conn.Read(buf)
	if err != nil {
		log.Printf("Error reading from connection: %v", err)
		return
	}

	request := string(buf[:reqLen])

	switch request {
		case "GIVEPUBKEY":
			err = givePublicKey(conn, keyStorage)
		case "SENDENC":
			// Add the required parameters for sendEncryptedResponse
			err = sendEncryptedResponse(conn, pubKeyModwareServer, ip, privKeyServer, pubKeyClient)
		default:
			err = fmt.Errorf("unknown request")
	}

	if err != nil {
		log.Printf("Error handling request '%s': %v", request, err)
	}
}

/**
 * description:
 *	The driver function for the program
 */
func main() {
	keyStorage := NewKeyStorage()

	err := filepath.Walk(keyDir, func(path string, info os.FileInfo, err error) error {
		if( info == nil ) {
			return nil
		}
		if !info.IsDir() && strings.HasSuffix(path, keyExtension) {
			ip := strings.TrimSuffix(info.Name(), keyExtension)
			pubKey, err := LoadPublicKey(path)
			if err != nil {
				return err
			}
			keyStorage.AddKey(ip, &pubKey)
			fmt.Printf("Loaded key for IP: %s\n", ip)
		}
		return nil
	})

	if err != nil {
		log.Fatalf("Error loading keys: %v", err)
	}

	listener, err := net.Listen(TYPE, HOST+":"+PORT)
	if err != nil {
		log.Fatalf("Error listening on %s:%s: %v", HOST, PORT, err)
	}
	defer listener.Close()

	printLog("socket listening")

	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Printf("Error accepting connection: %v", err)
			continue
		}
		go handleRequest(conn, keyStorage)
	}
}